<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>AR風 看板カメラ（スマホ対応・高解像度）</title>
<style>
html,body{height:100%;margin:0;background:#000;-webkit-user-select:none;user-select:none;}
#app{position:fixed;inset:0;display:flex;align-items:stretch;justify-content:stretch;}
video#cam{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;}
#overlay{position:absolute;inset:0;touch-action:none;}
.sticker{position:absolute;left:50%;top:50%;transform-origin:center center;will-change:transform;touch-action:none;user-select:none;-webkit-user-drag:none;max-width:90vw;max-height:80vh;pointer-events:auto;}
#ui{position:fixed;right:10px;bottom:10px;z-index:1000;display:flex;gap:8px;flex-direction:column;}
button{font-size:14px;padding:8px 10px;border-radius:8px;border:none;background:#fff;color:#111;}
</style>
</head>
<body>
<div id="app">
  <video id="cam" autoplay playsinline muted></video>
  <div id="overlay">
    <img id="sticker" class="sticker" src="ceremony_sign.png" alt="看板">
  </div>
</div>

<div id="ui">
  <button id="btnSnap">写真を撮る（ダウンロード）</button>
  <button id="btnReset">初期位置に戻す</button>
</div>

<script>
(async function(){
  const video = document.getElementById('cam');
  const sticker = document.getElementById('sticker');
  const overlay = document.getElementById('overlay');
  const btnSnap = document.getElementById('btnSnap');
  const btnReset = document.getElementById('btnReset');

  // カメラ起動（反転なし）
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: "environment" } }, 
      audio:false
    });
    video.srcObject = stream;
    video.style.transform = "none"; // 反転なし
  }catch(e){
    alert('カメラへのアクセスが必要です。ブラウザの設定で許可してください。');
    console.error(e);
    return;
  }

  // 看板の初期状態
  let state = { x:0, y:-80, scale:1, rotation:0 };
  function applyTransform() {
    sticker.style.transform = `translate(-50%,-50%) translate(${state.x}px,${state.y}px) scale(${state.scale}) rotate(${state.rotation}deg)`;
  }
  applyTransform();

  // タッチ・ドラッグ・ピンチ処理
  let pointers = new Map();
  let base = { x:0,y:0,scale:1,rotation:0,dist:0,angle:0,cx:0,cy:0 };
  function getCenter(p1,p2){ return { x:(p1.clientX+p2.clientX)/2, y:(p1.clientY+p2.clientY)/2 }; }
  function getDist(p1,p2){ return Math.hypot(p1.clientX-p2.clientX, p1.clientY-p2.clientY); }
  function getAngle(p1,p2){ return Math.atan2(p2.clientY-p1.clientY,p2.clientX-p1.clientX)*180/Math.PI; }

  overlay.addEventListener('pointerdown', e=>{
    overlay.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, e);
    if(pointers.size===1){
      base.x=state.x; base.y=state.y; base.cx=e.clientX; base.cy=e.clientY;
    } else if(pointers.size===2){
      const it=Array.from(pointers.values());
      base.dist=getDist(it[0],it[1]);
      base.angle=getAngle(it[0],it[1]);
      base.scale=state.scale;
      base.rotation=state.rotation;
      const c=getCenter(it[0],it[1]);
      base.cx=c.x; base.cy=c.y;
    }
  });
  overlay.addEventListener('pointermove', e=>{
    if(!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId,e);
    if(pointers.size===1){
      const dx=e.clientX-base.cx, dy=e.clientY-base.cy;
      state.x=base.x+dx;
      state.y=base.y+dy;
      applyTransform();
    } else if(pointers.size>=2){
      const it=Array.from(pointers.values());
      const dist=getDist(it[0],it[1]), angle=getAngle(it[0],it[1]);
      const scaleFactor = dist/base.dist;
      state.scale=Math.max(0.2, Math.min(5, base.scale*scaleFactor));
      state.rotation=base.rotation + (angle-base.angle);
      applyTransform();
    }
  });
  overlay.addEventListener('pointerup', e=>{ overlay.releasePointerCapture(e.pointerId); pointers.delete(e.pointerId); });
  overlay.addEventListener('pointercancel', e=>{ pointers.delete(e.pointerId); });
  overlay.addEventListener('wheel', e=>{ e.preventDefault(); state.scale=Math.max(0.2, Math.min(5,state.scale*(1-e.deltaY*0.001))); applyTransform(); });

  // 初期化
  btnReset.addEventListener('click', ()=>{
    state.x=0; state.y=-80; state.scale=1; state.rotation=0; applyTransform();
  });

  // 写真撮影（高解像度）
  btnSnap.addEventListener('click', ()=>{
    btnSnap.style.display='none';
    btnReset.style.display='none';

    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');

    // カメラ映像描画（反転なし）
    ctx.drawImage(video,0,0,canvas.width,canvas.height);

    // 看板描画
    const sRect = sticker.getBoundingClientRect();
    const vRect = video.getBoundingClientRect();
    const scaleX = canvas.width / vRect.width;
    const scaleY = canvas.height / vRect.height;
    const sx = (sRect.left - vRect.left) * scaleX;
    const sy = (sRect.top - vRect.top) * scaleY;
    const sw = sRect.width * scaleX;
    const sh = sRect.height * scaleY;

    ctx.save();
    ctx.translate(sx+sw/2, sy+sh/2);
    ctx.rotate(state.rotation*Math.PI/180);
    ctx.drawImage(sticker, -sw/2, -sh/2, sw, sh);
    ctx.restore();

    // ダウンロード
    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ar_photo.png';
    a.click();

    btnSnap.style.display='block';
    btnReset.style.display='block';
  });

})();
</script>
</body>
</html>
